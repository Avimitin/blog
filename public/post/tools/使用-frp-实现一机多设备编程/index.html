<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<title>使用 FRP 实现一机多设备编程 - sh1marin's Blog</title>
<meta name=description content="前言 最近配了台 ChromeBook 用来方便平常通勤写代码，但是 ChromeBook 羸弱的性能和拉跨的散热使得他日常编程体验极其垃圾。同时，回到宿舍之后用主机写代码和 ChromeBook 之间也会极">
<meta name=author content>
<link rel="preload stylesheet" as=style href=https://blog.sh1mar.in/app.min.css>
<link rel="preload stylesheet" as=style href=https://blog.sh1mar.in/an-old-hope.min.css>
<script defer src=https://blog.sh1mar.in/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=preload as=image href=https://blog.sh1mar.in/theme.png>
<link rel=preload as=image href=https://blog.sh1mar.in/twitter.svg>
<link rel=preload as=image href=https://blog.sh1mar.in/github.svg>
<link rel=icon href=https://blog.sh1mar.in/favicon.ico>
<link rel=apple-touch-icon href=https://blog.sh1mar.in/apple-touch-icon.png>
<meta name=generator content="Hugo 0.91.2">
<meta property="og:title" content="使用 FRP 实现一机多设备编程">
<meta property="og:description" content="前言 最近配了台 ChromeBook 用来方便平常通勤写代码，但是 ChromeBook 羸弱的性能和拉跨的散热使得他日常编程体验极其垃圾。同时，回到宿舍之后用主机写代码和 ChromeBook 之间也会极">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.sh1mar.in/post/tools/%E4%BD%BF%E7%94%A8-frp-%E5%AE%9E%E7%8E%B0%E4%B8%80%E6%9C%BA%E5%A4%9A%E8%AE%BE%E5%A4%87%E7%BC%96%E7%A8%8B/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2020-10-25T00:00:00+00:00">
<meta property="article:modified_time" content="2020-10-25T00:00:00+00:00">
<meta itemprop=name content="使用 FRP 实现一机多设备编程">
<meta itemprop=description content="前言 最近配了台 ChromeBook 用来方便平常通勤写代码，但是 ChromeBook 羸弱的性能和拉跨的散热使得他日常编程体验极其垃圾。同时，回到宿舍之后用主机写代码和 ChromeBook 之间也会极"><meta itemprop=datePublished content="2020-10-25T00:00:00+00:00">
<meta itemprop=dateModified content="2020-10-25T00:00:00+00:00">
<meta itemprop=wordCount content="1651">
<meta itemprop=keywords content="frp,cooporate,">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="使用 FRP 实现一机多设备编程">
<meta name=twitter:description content="前言 最近配了台 ChromeBook 用来方便平常通勤写代码，但是 ChromeBook 羸弱的性能和拉跨的散热使得他日常编程体验极其垃圾。同时，回到宿舍之后用主机写代码和 ChromeBook 之间也会极">
</head>
<body class=not-ready data-menu=false>
<header class=header>
<p class=logo>
<a class=site-name href=https://blog.sh1mar.in>sh1marin's Blog</a><a class=btn-dark></a>
</p>
<script>let bodyClx=document.body.classList,btnDark=document.querySelector('.btn-dark'),sysDark=window.matchMedia('(prefers-color-scheme: dark)'),darkVal=localStorage.getItem('dark'),setDark=a=>{bodyClx[a?'add':'remove']('dark'),localStorage.setItem('dark',a?'yes':'no')};setDark(darkVal?darkVal==='yes':sysDark.matches),requestAnimationFrame(()=>bodyClx.remove('not-ready')),btnDark.addEventListener('click',()=>setDark(!bodyClx.contains('dark'))),sysDark.addEventListener('change',a=>setDark(a.matches))</script>
<nav class=social>
<a class=twitter style=--url:url(./twitter.svg) href=https://twitter.com/twitter.com/sh1ma_rin target=_blank></a>
<a class=github style=--url:url(./github.svg) href=https://github.com/github.com/Avimitin target=_blank></a>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-title>
<p>
<time>Oct 25, 2020</time>
</p>
<h1>使用 FRP 实现一机多设备编程</h1>
</header>
<section class=post-content><h2 id=前言>前言</h2>
<p>最近配了台 ChromeBook 用来方便平常通勤写代码，但是 ChromeBook 羸弱的性能和拉跨的散热使得他日常编程体验极其垃圾。同时，回到宿舍之后用主机写代码和 ChromeBook 之间也会极其脱节。</p>
<p>也有考虑过用 git 分支来管理代码，但是有时候代码写了一半还有很多问题没调试，不想提交 commit 。或者使用 SAMBA 直接对笔记本的代码进行修改，这样又会遇到跨平台编译的问题。</p>
<p>于是我用了一段时间的 VSCode 的 Remote SSH 插件，在外用 ChromeBook，回到宿舍之后主机 SSH 连接 ChromeBook 来写代码。但是这样有些本末倒置了：本来性能更好的主机却只做了显示器的功能。于是我这周和朋友了解了一下 frp 并重新设计了部署方案。</p>
<h2 id=设计>设计</h2>
<p>一机多设备编程部署方案：</p>
<p><img src=https://cdn.jsdelivr.net/gh/Avimitin/PicStorage/pic/20201025132138.png alt="Design By XMind"></p>
<p>一台高性能的本地服务器主机用作编译主机，部署 frp 服务到一台有公网 IP 的 VPS主机上，然后别的设备通过 VPS 转发流量到本地主机上来操作本地服务器。</p>
<h2 id=平台>平台</h2>
<p>我的本地服务器用的 Ubuntu 20.4，公网服务器用的 Debian Buster。</p>
<h2 id=部署>部署</h2>
<p>首先下载 <a href=https://github.com/fatedier/frp>FRP</a> ，根据自己的系统和处理器选择，我这边选的 <a href=https://github.com/fatedier/frp/releases/download/v0.34.1/frp_0.34.1_linux_amd64.tar.gz>linux-amd64</a> 版本。解压之后里面有两个程序，一个是 <code>frps</code> ，一个是 <code>frpc</code> ，分别对应服务器和客户端两个程序。</p>
<blockquote>
<p>下面所述的字段在 <a href=https://gofrp.org/docs/>FRP Docs</a> 里都有详细介绍，你可以根据自己需求更改。</p>
</blockquote>
<h3 id=frps服务器端>FRPS（服务器端）</h3>
<p>将 <code>frps</code> 和 <code>frps.ini</code> 用 SFTP 发送到公网IP服务器，然后修改 <code>frps.ini</code> ：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=color:#75715e>;common 就是通用设置</span>
<span style=color:#66d9ef>[common]</span>
<span style=color:#75715e>;服务端监听端口，建议修改防止被扫</span>
<span style=color:#a6e22e>bind_port</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>7000</span>
<span style=color:#75715e>;token设置</span>
<span style=color:#a6e22e>token</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>12345qwert</span>
<span style=color:#75715e>;端口复用设置</span>
<span style=color:#a6e22e>tcp_mux</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>true</span>
<span style=color:#a6e22e>tcpmux_httpconnect_port</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>7001</span>
<span style=color:#75715e>;log文件设置</span>
<span style=color:#75715e>;我这边没有设置，我使用的另外一个方法获取log</span>
<span style=color:#75715e>;有需求可以去掉前面的分号来启用自定义log</span>
<span style=color:#75715e>;log_file = /run/logs/frps/frps.log</span>
<span style=color:#75715e>;log_level = info</span>
</code></pre></div><p>然后使用 <code>./frps -c frps.ini</code> 测试启动成功与否。按 <code>Ctrl + C</code> 停止程序。你还要记得在VPS面板更改防火墙设置把自己设置的端口打开。</p>
<h3 id=frpc客户端>FRPC（客户端）</h3>
<p>然后把 <code>frpc</code> 和 <code>frpc.ini</code> 复制到本地服务器，修改 <code>frpc.ini</code> ：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=color:#66d9ef>[common]</span>
<span style=color:#75715e>;这里填公网IP的机子的地址还有端口</span>
<span style=color:#a6e22e>server_addr</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>xxx.xx.xxx.xxx</span>
<span style=color:#a6e22e>server_port</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>7000</span>
<span style=color:#75715e>;token服务端和客户端要一致</span>
<span style=color:#a6e22e>token</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>12345qwert</span>
<span style=color:#75715e>;然后自定义一个方案名</span>
<span style=color:#66d9ef>[SSH]</span>
<span style=color:#a6e22e>type</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>tcp</span>
<span style=color:#75715e>;如果想要访问局域网内别的设备这里就填局域网别的设备的ip</span>
<span style=color:#a6e22e>local_ip</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>127.0.0.1</span>
<span style=color:#a6e22e>local_port</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>22</span>
<span style=color:#75715e>;remote_port 建议修改，防止被扫</span>
<span style=color:#a6e22e>remote_port</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>6000</span>
</code></pre></div><blockquote>
<p>这里的 remote_port 是公网服务器监听的端口，即若有对 xxx.xxx.xxx.xxx:6000 的请求，公网服务器就会把请求转发到内网的 127.0.0.1:22 地址上。所以 remote_port 也要记得在公网服务器的防火墙里打开。</p>
</blockquote>
<p>在公网服务器启动 frps 服务端，然后使用 <code>./frpc -c frpc.ini</code> 测试连接成功与否，如果成功连接公网服务器的 frps 服务端会有 <code>client login info</code> 的提示，然后会看到两边都有 <code>new proxy [ssh] success</code> 的提示，就代表转发代理建立成功了。然后你可以在任意一台设备上使用</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>ssh xxx@xxx.xxx.xxx.xxx -p <span style=color:#ae81ff>6000</span>
</code></pre></div><p>来测试 SSH 转发成功与否。大部分失败都是因为防火墙没有打开对应端口。</p>
<h2 id=安全性>安全性</h2>
<p>由于将内网机器暴露在公网，SSH 尽量不使用明文密码登录，建议使用 pubkey 进行设备认证。</p>
<h3 id=公钥生成并监听>公钥生成并监听</h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e>#生成公钥</span>
ssh-keygen -t rsa -C <span style=color:#e6db74>&#34;example@gmail.com&#34;</span>
eval <span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>ssh-agent -s<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>
<span style=color:#75715e>#私钥监听</span>
ssh-add ~/.ssh/id_rsa
</code></pre></div><h3 id=公私钥认证>公私钥认证</h3>
<p>在服务器端下的 <code>.ssh</code> 文件夹修改或者创建文件 <code>authorized_keys</code> 。在里面追加公钥(<code>.pub</code>结尾的文件)</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># 客户端查看并复制公钥</span>
cat ~/.ssh/id_rsa.pub
<span style=color:#75715e># 追加到 authorized_keys 里</span>
</code></pre></div><p>每个设备的公钥占一行，隔行来分辨不同设备。</p>
<h3 id=设置仅公钥登录>设置仅公钥登录</h3>
<p>在本地服务器打开 <code>/etc/ssh/sshd_config</code> , 首先建议把默认的 22 端口修改为高位的端口减少被扫的次数（这里假如修改了记得要去 <code>frpc.ini</code> 修改本地端口）。然后找到 <code>PubKeyAuthentication</code> 字段，删掉前面的 # 号注释，并改为 <code>yes</code> 。找到 <code>PasswordAuthentication</code> 字段并改为 <code>no</code> 。这样就不能再用密码登录了。</p>
<h2 id=持续可用性>持续可用性</h2>
<p>我使用 <code>systemd</code> 来进行进程维护。下载的压缩包里已经有写好的 <code>.service</code> 文件，根据文件名复制到对应机子的 <code>/etc/systemd/system/</code> 文件夹下。并根据 <code>.service</code> 文件里的内容把程序和配置文件复制到对应文件，我选择修改 <code>.service </code> 文件。拿服务器端举例：</p>
<ol>
<li>首先 <code>mv frps /usr/bin/</code> 移动 frps 到 <code>/usr/bin</code> 目录下。</li>
<li>然后 <code>cp ./frps.ini /usr/local/frps</code> 复制配置文件到 <code>/usr/local/frps</code> 下。</li>
<li>打开 <code>frps.service</code> 文件，将 ExecStart 字段修改为 <code>/usr/bin/frps -c /usr/local/frps/frps.ini</code></li>
<li>将 ExecReload 字段修改为 <code>/usr/bin/frps reload -c /usr/local/frps/frps.ini</code></li>
<li>然后 <code>cp frps.service /etc/systemd/system</code> 复制到 systemd 目录下。</li>
<li>每次修改 service 文件都需要 <code>sudo systemctl daemon-reload</code> 。</li>
<li>启动 frp : <code>sudo systemctl start frps</code></li>
<li>重启 frp : <code>sudo systemctl restart frps</code></li>
<li>关闭 frp：<code>sudo systemctl stop frps</code></li>
<li>查看 frp 状态 : <code>sudo systemctl status frps</code></li>
<li>frp 开机自启 : <code>sudo systemctl enable frps</code></li>
<li>frp log 查询 : <code>journalctl -au frps.service</code> 或 <code>journalctl -au frps.service -f</code> 查看最新日志并等待新日志输出。</li>
</ol>
<h2 id=vscode-ssh-remote>VSCode SSH Remote</h2>
<p>部署完毕之后就是 VSCode 的设置了，安装好插件之后点击左下角的 SSH 按钮，在弹出菜单中点选 <code>Remote-SSH Open Configuration File</code> ，选择 config 存放位置，在里面填入</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#ae81ff>Host xxx</span>
	<span style=color:#ae81ff>HostName xxx.xxx.xxx.xxx</span>
	<span style=color:#ae81ff>User xxx</span>
	<span style=color:#ae81ff>Port 6000</span>
	<span style=color:#ae81ff>IdentityFile &#34;~/.ssh/id_rsa&#34;</span>
</code></pre></div><blockquote>
<ul>
<li>Host 任意填名字</li>
<li>HostName 填公网IP</li>
<li>User 就是登录用户名</li>
<li>Port 远程端口，即我们设置的转发端口 6000</li>
<li>IdentityFile 填私钥地址</li>
</ul>
</blockquote>
<p>然后就可以多设备同机编程了。</p>
</section>
<footer class=post-tags>
<a href=https://blog.sh1mar.in/tags/frp>frp</a>
<a href=https://blog.sh1mar.in/tags/cooporate>cooporate</a>
</footer>
<nav class=post-nav>
<a class=prev href=https://blog.sh1mar.in/post/coding/%E5%BC%80%E5%8F%91%E8%80%85%E9%9C%80%E8%A6%81%E7%9A%84%E5%A5%BD%E4%B9%A0%E6%83%AF/><span>←</span><span>8个开发者需要的好习惯</span></a>
<a class=next href=https://blog.sh1mar.in/post/coding/%E7%94%A8python%E5%AE%9E%E7%8E%B0jwt/><span>使用 Python 实现 JSON Web Token</span><span>→</span></a>
</nav>
</article>
</main>
<footer class=footer>
<p>&copy; 2022 <a href=https://blog.sh1mar.in>sh1marin's Blog</a></p>
<p>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>️</p>
<p>
<a href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Paper 5.1</a>
</p>
</footer>
</body>
</html>