<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on sh1marin&#39;s Blog</title>
    <link>https://blog.sh1mar.in/post/</link>
    <description>Recent content in Posts on sh1marin&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 04 Jan 2022 19:39:58 +0800</lastBuildDate><atom:link href="https://blog.sh1mar.in/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>My First</title>
      <link>https://blog.sh1mar.in/post/my-first/</link>
      <pubDate>Tue, 04 Jan 2022 19:39:58 +0800</pubDate>
      
      <guid>https://blog.sh1mar.in/post/my-first/</guid>
      <description>Title Lorem ipsum dolor sit amet, officia excepteur ex fugiat reprehenderit enim labore culpa sint ad nisi Lorem pariatur mollit ex esse exercitation amet. Nisi anim cupidatat excepteur officia. Reprehenderit nostrud nostrud ipsum Lorem est aliquip amet voluptate voluptate dolor minim nulla est proident. Nostrud officia pariatur ut officia. Sit irure elit esse ea nulla sunt ex occaecat reprehenderit commodo officia dolor Lorem duis laboris cupidatat officia voluptate. Culpa proident adipisicing id nulla nisi laboris ex in Lorem sunt duis officia eiusmod.</description>
    </item>
    
    <item>
      <title>8个开发者需要的好习惯</title>
      <link>https://blog.sh1mar.in/post/%E5%BC%80%E5%8F%91%E8%80%85%E9%9C%80%E8%A6%81%E7%9A%84%E5%A5%BD%E4%B9%A0%E6%83%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sh1mar.in/post/%E5%BC%80%E5%8F%91%E8%80%85%E9%9C%80%E8%A6%81%E7%9A%84%E5%A5%BD%E4%B9%A0%E6%83%AF/</guid>
      <description>今天看到的一个很有价值的文章，决定自行翻译，英语水平有限，有歧义欢迎指出，原文地址 。
 最佳做法 (Best Practices)  这段标题仍有改进空间
 #1： 把解决问题放在第一位 许多贡献者都十分具有创造力，并且他们十分享受设计抽象数据结构，创造友好的用户界面，亦或只是简单享受编程的过程。不管是什么情况，他们常常会产生一些很棒的想法，但是这些想法很多时候可能对解决实际问题并没有什么帮助。
这常常被称为 用办法寻找问题 。这种做法可能没有什么坏处，但是在现实生活中，你需要花时间去写这些没有太大用处的代码，写好的代码需要占用空间来编译和存放，且一段代码写好了就需要你花费精力去维护，这对你来说并没有什么太大的益处。对于软件开发者而言，不增加任何无意义的额外工作永远被认为是一种最好的做法。
#2：解决最关键的问题 这一段是对上一个话题的延伸。我们已经知道增加任何多余的东西不是一个好做法，但是什么因素能决定这么做是必要的亦或是不必要的呢？
答案就是：我们需要解决的这个问题必须先实际存在，而不是靠臆想产生出来的。用户使用软件旨在创造一些他们需要的东西，在这个过程中，他们可能会陷入一些问题导致工作不得不暂停，或是生产力被这些问题所拖累。在这种情况下，我们才需要去解决这个问题。
相信某个问题未来总是会出现，所以软件必须提前做好准备，在问题出现时立刻解决，这种行为被称为“未来打样”。通常表现为：
 我觉得这样可能对用户会比较有用&amp;hellip; 我觉得用户最终会需要&amp;hellip;  然而这常常被认为是一种坏习惯。因为总是为未出现的问题设计代码会导致这段代码可能并不会被使用到，或者会导致代码比起实际更加难以使用和维护。
#3：解决那些比较复杂或常常出现的问题 软件虽然被设计出来的目的是解决问题，但是我们并不能指望它能解决世界上出现的所有问题。作为一个游戏引擎，Godot 会为你解决游戏制造上的问题，帮助你把游戏做的质量更好，效率更高。但是 Godot 并不能帮助你完成整个游戏。引擎的能力总是有限的。
一个问题是否值得被解决由用户的解决难度来决定，这里的解决难度可以被解释为：
 问题的复杂程度 问题的频繁程度  如果这个问题对于绝大部分的用户来说都过于复杂，那么软件就必须提供一个现成的解决方案。同样的，如果这个问题对于用户而言很好解决，那么并没有必要提供解决方案，且这个问题也应该由用户自行解决。
然而，虽然问题解决起来很轻松，但是用户频繁的遇到这个问题，每一次都需要费工夫去解决这么一个小问题，那么在这种情况下，软件就需要提供一种解决方案来简化使用流程来提高使用体验。
在我们的实际经历中，很多时候你是可以很清楚的分辨这个问题是否值得去解决，但是总会出现难以划定标准的时候。这就是为什么我们总是推荐和其他开发者交流。
#4 必须和他人交流自己的解决办法 我们常常会遇到一种情况，当你陷入某个问题时，你可能只会沉迷于自己的项目，因此你会很自然的只站在自己的角度，只从自己的视角来解决问题。因此，你的解决办法不会总考虑到别的程序员已经常常注意的情况。
对于开发者来说，每个开发者的看法都是不一样的，有的人可能会觉得用户的问题实在是太过于独特，不必单独设计解决方案，有的可能会对一些更加复杂的问题建议一些过于片面简单的做法，然后遗留剩下的问题给用户自己去解决。
不管是什么情形，在尝试做贡献时，和别的开发者讨论你在实际正在解决的问题是十分重要的，因此也能达成一个更多人赞同的实践。
只有在一种情况下是特殊的，当在某片领域还没有人做出令大部分人满意的贡献时，某些于用户直接交流并拥有丰富知识的人可以直接做出解决方案。
同时，Godot 的开发哲学是，更易用和更易维护比绝对的性能更重要。性能优化会在后期考虑，但是假如为了性能而牺牲易用性，牺牲代码清晰度，这是无法被接受的。
#5 不同的问题用不同解法 对于程序员来说，最有意思的挑战就是去找到各种问题的最佳解法。然而问题可能会过多，导致程序员尝试用一种解法去应对各种问题。
当你想要让解决办法更加灵活多变，能适应各种问题，情况就会变得更加糟糕，而我们在第二节提到的 “臆想出来的问题” 也会在这种情况下出现。
最主要的问题就是，在现实中，很少会需要用到这种解法的。绝大部分时间，对于每个独立的问题，用单独的代码去解决他们会更加简单且更易于维护。
另外，用来分割问题的解法对于用户也更加友好，他们可以不需要学习并记忆整个复杂的系统，他们只需要他们需要用的东西。
庞大且灵活的解法还有一个弊病就是，随着时间的推移，他们的灵活性会逐渐下降，这就要求程序员不断的往里添加新的方法，而这会导致代码和 API 越来越复杂。
#6 迎合更加常见的用户情形，对罕见情形留一条路 这是前面一点的延续，在这节会更加深度的解释为什么我们会推荐这种想法和这种设计方式。
就像我们在第二点提到的，对于一个普通人来说，去了解所有未来可能会出现的需求是十分困难的，尝试去写一个对所有情形都通用的结构常常是一种错误做法。
我们可能会写一些我们觉得很酷的功能，但是在生产环境中，我们可能会发现用户几乎不会用到这些功能，或者他们的需求与我们的最初的开发方向大相径庭，让我们不得不把无用的功能抛弃，或是让整个程序变得更加复杂。
所以问题就是，我们要怎样设计一个软件，可以给予用户一些我们知道他们需要的功能，但是又足够灵活，能给予用户一些我们不知道他们是否需要的功能。
答案如图所示，想要让用户能够随心所欲的使用，我们只需要给他们一些低权限的 API 接口，让他们能够用来满足他们的需求，就算可能会因为重新实施一些重复的逻辑来增加他们的工作量。
在现实生产环境中，这种情况可能很少见，但是设计自定义的解决方案仍然是有意义的，这也是为什么提供基础的设计模块给用户是重要的。
#7： 解决方案必须本地化 当你正在为一个问题寻求解决方案，亦或是实施一些新特性，或是修一个 bug， 很多时候最简单的办法是往核心代码里添加新数据或新方法。</description>
    </item>
    
    <item>
      <title>Arch Linux Installation Guide</title>
      <link>https://blog.sh1mar.in/post/arch-installation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sh1mar.in/post/arch-installation/</guid>
      <description>Arch installation Get arch Download Arch Linux from https://archlinux.org/download/ and follow guide from https://wiki.archlinux.org/index.php/Installation_guide
Before boot (OPTIONAL) You can press e to edit install configuration like:
# If you think the screen is too small. nomodset video=800x450 Setting font (OPTIONAL) If you think the font is too small and hard to look, you can change font for a more comfortable look.
setfont /usr/share/kbd/consolefonts/LatGrkCyr-12x12.gz Configure key (OPTIONAL) touch keys.conf #-------edit--------# keycode 1 = Caps_Lock keycode 58 = Escape #----end of edit-----# loadkeys keys.</description>
    </item>
    
    <item>
      <title>Canokeys and GPG</title>
      <link>https://blog.sh1mar.in/post/security/canokeys/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sh1mar.in/post/security/canokeys/</guid>
      <description> </description>
    </item>
    
    <item>
      <title>Golang Polling Control Flow</title>
      <link>https://blog.sh1mar.in/post/golang/circulate_job_gurdian_in_go/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sh1mar.in/post/golang/circulate_job_gurdian_in_go/</guid>
      <description>Go 的循环任务守护 前言 这几天在做的一个项目里，有一个功能需求是：长期运行一个轮询任务，通过轮询得到的返回的信息进行下一步操作。这个问题初一看是蛮简单的，就一个 for 循环的事情嘛。但是实际上还有很多细节的地方需要仔细处理。本篇文章建立在你有足够的 Go 语言基础且懂得 chan 、 select 、go 关键字的用法的基础上。文章代码是逐步完善的伪代码，请自行推演，不要复制粘贴。
简单的无限循环 基于分治的思想，我们把这个任务给分成几个小任务：
 执行一次请求 把一次请求改为轮询 对执行中的轮询进行控制  首先先写好请求的代码：
package main import ( &amp;#34;net/http&amp;#34; &amp;#34;log&amp;#34; &amp;#34;fmt&amp;#34; ) func Request(url string) ([]byte, error) { resp, err := http.Get(url) if err != nil { log.Println(&amp;#34;[Error]Http get error,&amp;#34;, err) return nil, err } return resp, nil } func main() { resp, err := Request() if err != nil { log.Println(&amp;#34;[Error]Request error,&amp;#34;, err) return } fmt.</description>
    </item>
    
    <item>
      <title>HashMap::Entry 的 or_insert 返回了什么</title>
      <link>https://blog.sh1mar.in/post/rust/what_does_hashmap_entry_or_insert_return/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sh1mar.in/post/rust/what_does_hashmap_entry_or_insert_return/</guid>
      <description>HashMap::Entry 的 or_insert 返回了什么 Tags: Language Specific
这几天学 Rust 的时候看到的一块代码给我带来了一点疑惑：
use std::collections::HashMap; fn main() { let mut hashmap = HashMap::new(); let foo = hashmap.entry(&amp;#34;foo&amp;#34;).or_insert(1); println!(&amp;#34;foo has value {}&amp;#34;, foo); *foo += 1; println!(&amp;#34;foo has value {}&amp;#34;, foo); println!(&amp;#34;hashmap now store key-value pair: {:?}&amp;#34;, hashmap); } 在这里我定义了一个新的哈希表变量 hashmap，并使用 HashMap.entry().or_insert() 方法在检测到没有 &amp;quot;foo&amp;quot; 这个键的时候，插入键值对 &amp;quot;foo&amp;quot; = 1 ，并返回一个值，这个值可以进行解引用操作，并自增一位。
编译之后程序会输出：
$ rustc main.rs &amp;amp;&amp;amp; ./main foo has value 1 foo has value 2 hashmap now store key-value pair: {&amp;#34;foo&amp;#34;: 2} 可以看到，不止 foo 的值自增了，hashmap 里的值也自增了一位。只看代码，貌似 foo 是一个指向哈希表里的值的引用。但是没有声明 mut，为什么我可以解引用并修改他的值呢，如果要修改我难道不应该用 let mut foo = .</description>
    </item>
    
    <item>
      <title>How to write commit</title>
      <link>https://blog.sh1mar.in/post/git/how-to-write-commit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sh1mar.in/post/git/how-to-write-commit/</guid>
      <description>前言 对我而言，撰写 git commit 的内容是一个很重要的事情。因为我会把 commit 里的信息当成一份邮件，在开源社区里每个人都需要知道我做了什么，我为什么 要这么做，而编写 commit，就像在群发邮件一样。一份清晰的 commit 信息可以 给后续开发带来很多方便，也是对自己行为的一种声明。
我也一直在实践中找出一份简单但清晰的 commit 规则，以下内容 是我目前总结出来的比较简单但清晰的一份模板，我也会在后续不断重构不断更新。
结构 首先需要对 commit 要包含什么内容有一个清晰的概念。一个 commit 需要包含标题、 正文、脚注三个部分。每一部分都应该用一个空行分开。
标题 commit 的标题应当简洁明了的陈述你做了什么。注意我用的字眼：“陈述”。最好不要在 标题里包含任何时态，任何语气符号以及任何夸张用词。同时为了历史记录的一致性， 推荐用全小写来书写你的标题。
对比以下两个 commit，你更喜欢那一种呢？
I&amp;#39;ve fixed almost all the problems! ----------------------------------- fix(socket): clean up buffer when establish to new socket 我个人的品味是更倾向于选择下面这种书写方式，清晰明了的说明了做了什么(fix)， 对什么做了修改(socket)，大概做了哪些修改(正文)。
相信有些读者可能对这种写法非常熟悉，他来自于著名的开源框架 Angular。 Angular 的贡献指南里明确的约定了如下的标题书写格式：
&amp;lt;type&amp;gt;(&amp;lt;scope&amp;gt;): &amp;lt;short summary&amp;gt; │ │ │ │ │ └─⫸ Summary in present tense. Not capitalized. No period at the end.</description>
    </item>
    
    <item>
      <title>neovim 的简易教程</title>
      <link>https://blog.sh1mar.in/post/neovim/neovim-tutorial/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sh1mar.in/post/neovim/neovim-tutorial/</guid>
      <description>前言 最近我打算开一个 neovim 系列，这个博客系列会分成几块来讲，首先是 neovim 的一些键位和 设置，然后再讲如何配置 packer 这个插件管理器，之后就是零零碎碎的写一写插件介绍。
我的配置文件教程会基于 Lua 和 neovim 0.5+ 来配置。所以如果你是打算用 vim 的，因为 vim 仅支持 vimscript，这篇文章可能会不太适合你。
本来是想写一点类似于卖安利的文字的。不过最近实在疲于给别人推荐他们并不感兴趣的东西， 所以我就不在这里多费口舌介绍 neovim 的优势了。这篇文章主要还是写给那些对 neovim 感兴 趣但是不知道怎么入手的人。
neovim 的一些基础操作 安装好 neovim 之后，在命令行输入 nvim 打开 neovim。在打开的界面的左上角，有一个长方 体，那个就是你的光标。中间有许多提示文字，提示让你输入 :help, :q, :checkhealth。
如果你是第一次用 neovim，通常会对这个界面感到困惑，这很正常，不必担心。我会在这一节教 授你一些基础的 neovim 用法，足够你进行基本的文字编辑。
首先我想要讲的是如何退出 neovim。对于每一个第一次使用 vim 的新手，如何退出 vim 就如同 灰烬审判者古达一样，把他们拦在熟练使用 vim 的大门之外。退出 vim 是如此困难，以至于所 有人都在玩退出 vim 的梗。虽然 neovim 默认给 &amp;lt;CTRL&amp;gt;-c 按键绑定上了退出提示，但是 搞明白 neovim 的提示也让新手们费了不少功夫。
所有新手最不明白的一个问题可能就是 :q 到底是什么意思。在哪里输入 :q，
配置文件 neovim 的配置通常从一个 init.</description>
    </item>
    
    <item>
      <title>Self-Hosted 的 CI/CD 软件 Drone 安装配置实战</title>
      <link>https://blog.sh1mar.in/post/self-hosted-%E7%9A%84-cicd-%E8%BD%AF%E4%BB%B6-drone-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%AE%9E%E6%88%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sh1mar.in/post/self-hosted-%E7%9A%84-cicd-%E8%BD%AF%E4%BB%B6-drone-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%AE%9E%E6%88%98/</guid>
      <description>Drone 安装配置实战 前言 因为穷用不起 GitLab，又想拥有一个自己的代码分发平台，于是搭建了自己的 Gitea，然而因为 Gitea 没有 DevOps，我不得不设置多一条 remote 上游来嫖 GitHub action 来用。这个寒假趁着事情不多，花了2个小时折腾了一下可独立部署的 CI/CD 程序：Drone。
安装 Drone 你需要：一台公网服务器；一台性能不错的服务器；GitHub，GitLab，Gitea 或者任意你正在使用且支持 Drone 的平台；一个域名。
下载 为了干净和快，Server 和 Runner 都采用了 Docker 来安装。所以首先要把 Docker 装上
安装 Docker 下面的方法仅适用于 Ubuntu，别的 Linux 发行版建议前往官网查询安装方法 。
# 安装配置 https 源的依赖 sudo apt-get install \  apt-transport-https \  ca-certificates \  curl \  gnupg-agent \  software-properties-common # 增加 Docker 的签名 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - # 确认签名是否相同 sudo apt-key fingerprint 0EBFCD88 pub rsa4096 2017-02-22 [SCEA] 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 uid [ unknown] Docker Release (CE deb) &amp;lt;docker@docker.</description>
    </item>
    
    <item>
      <title>Sign Your Commit With GPG</title>
      <link>https://blog.sh1mar.in/post/git/sign-your-commit-with-gpg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sh1mar.in/post/git/sign-your-commit-with-gpg/</guid>
      <description>使用 GPG 来签名 Commit 前几天一个朋友在群里提出了一个我从未考虑过的问题： “如果我在一个项目里用你的邮箱 commit，你会知道吗？”。
这个问题把我问住了。众所周知，在第一次使用 git 的时候，我们需要填写以下两个信息：
git config --global user.name &amp;#34;tom&amp;#34; git config --global user.email &amp;#34;tom@example.com&amp;#34; 当你进行项目开源或者和他人合作时，别人就可以在 commit 历史里用这些信息查询到是你提交的这条 commit 。你所 使用的代码托管平台甚至还会依据你填写的这些作者信息， 让你荣登 Contributor 之列。
似乎没什么问题的样子，为什么我还要大费周章的写一篇 《使用 GPG 签名 Commit》，上面提到的逻辑究竟发生了 什么问题呢。
小剧场 想象这么一个场景：现在是凌晨两点，你奋战了一天，终于 把一个顽固的代码 Bug 修好了。你感觉到一阵昏昏欲睡，想 赶紧上床好好休息一下。带着对自己代码的满足感，你 commit 了自己的心血： &amp;quot;fix: fixed the security valnerability&amp;quot; 你推送到了自己的代码托管平台，等待明早的新版本推送前， 大家对你进展的检查和评价。你爬上床，关好灯，困意逐渐 渗透，你开始意识模糊了起来&amp;hellip;&amp;hellip;
突然，邮件和各种通讯软件的通知声把你轰炸了起来，你 困惑的思考着似乎自己才刚进入梦乡，怎会这么快就到白天。 而接下来屏幕里的内容，更让你震撼的坚信自己还未睡醒： 大家都在责怪你的新 commit 让整个项目都混乱了。
你赶忙打开电脑，检查起 git log。你一行一行的查看 commit 哈希值，你找到了让项目崩坏的 patch，你不认识它，你从未 写过任何一行存在在 patch 里的改动，但令你绝望的是，这个 patch 上签署着你的名字，你的邮箱。毫无疑问，就是你，提交 的这个 commit。</description>
    </item>
    
    <item>
      <title>Simple Terminal - simple and suckless terminal</title>
      <link>https://blog.sh1mar.in/post/simple-terminal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sh1mar.in/post/simple-terminal/</guid>
      <description>Simple Terminal 的搭建和配置 前言 Simple Terminal 是一个基于 X 的终端，拥有非常棒的 Unicode 和 Emoji 的支持，同时也支持 256 色，拥有绝大部分的终端特性，但是却极其微小，就算在我打了许多补丁之后，他仍然只占用 108K 的存储空间，快且轻量，是重度终端用户的一个很不错的选择。
本篇文章目的在教你打造一个自己的 st，如果没有需求也可以前往我的仓库克隆我的源码，直接编译安装就可以了。
下载源码 Simple Terminal 的官网：https://st.suckless.org/ ，不需要下载 Download 的那个 st ，直接 clone 源码仓库就好：
git clone https://git.suckless.org/st 安装依赖 Simple Terminal (以下简称 st) 需要 libx11-dev 和 libxft-dev 两个包，对于 Debian 和 Ubuntu 用户来说直接使用 apt 安装即可，Arch 系的大部分发行版都已经包含。
克隆官方的仓库之后，编辑 config.mk 文件，编译时 st 会基于这个文件进行配置，一般来说只需要改两行即可：
X11INC = /usr/local/X11 X11LIB = /usr/local/X11 然后用 root 权限执行编译安装：
sudo make clean install 文件会复制到 /usr/local/bin/ 目录下，一般直接执行就能启动。</description>
    </item>
    
    <item>
      <title>Teach Yourself Programming in Ten Years</title>
      <link>https://blog.sh1mar.in/post/teach-yourself-programming-in-ten-years/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sh1mar.in/post/teach-yourself-programming-in-ten-years/</guid>
      <description>This artical is written by Peter Norvig, and here is a backup version.
 Why is everyone in such a rush? Walk into any bookstore, and you&amp;rsquo;ll see how to Teach Yourself Java in 24 Hours alongside endless variations offering to teach C, SQL, Ruby, Algorithms, and so on in a few days or hours. The Amazon advanced search for title: teach, yourself, hours, since: 2000 and found 512 such books.</description>
    </item>
    
    <item>
      <title>Windows Server 2019搭建NAS</title>
      <link>https://blog.sh1mar.in/post/windows-server-2019%E6%90%AD%E5%BB%BAnas%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sh1mar.in/post/windows-server-2019%E6%90%AD%E5%BB%BAnas%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</guid>
      <description>Windows Server 2019搭建NAS的一些总结 前言 前几天心血来潮想要搭建NAS，尝试在Windows Server 2019上搭建，经过30多个小时的折腾以后，被Windows的防火墙，文件权限和账户管理弄到崩溃；被Linux的众多命令和软件迭代浪费不少时间。谷歌了不少资料和文档，发现没有见到过完整的，能够手把手教学的NAS搭建教学和问题总结，走了不少弯路，有些问题到现在都还没有解决。所以为了方便自己之后的检索和其他入门朋友的学习，我把自己看的资料给整理摘录起来，并且记录一些经验。 总结分Windows Server（半成品，大多为失败的经验）和Ubuntu（完成度已经满足个人需求）两个环境，如果你是Linux平台使用者请看我下一篇文章。
  Windows Server 2019 环境下NAS搭建问题总结
 我对NAS的要求是这样的：
  SAMBA共享，做一个本地云盘，身边移动设备随时拷贝设备。 离线下载机，通过web管理任务。 家庭影院站点。 全WEB管理，不需要额外管理硬件（不用外接显示器鼠标键盘）   那么就先从系统搭建开始，黑群晖是不会去考虑的了，又不可靠也不方便，折腾起来要人命。于是就在Windows Server和Linux之间选择。考虑着自己是小白，而且已经习惯了Windows的交互方式，所以一开始选择了Windows Server（以下简称WS）。
 那么就开始WS的安装 (心态崩溃的说，我觉得直接用Win10搭建更省力。)
先从MSDN上下载了WS2019【ed2k链接得用迅雷下载嗷】。
下载完之后用UltraISO烧录进U盘。
然后点击工具栏的启动，选择 写入硬盘映像 。
写入完成以后重启，按F12（看你的系统boot选项），选择U盘安装，其余步骤就自己选择，不在这里细讲
注意：最好选择带有桌面体验的版本，不然进去就是PowerShell配置，满屏命令让你怀疑人生。
 Windows Server初步配置[1] 系统安装好以后首先第一步是要处理账户问题，对于一台NAS机来说首先最重要的就是摁下开机键马上就开始工作，所以免密登陆是必要的。
我们用 Win+R运行gpedit.msc打开组策略编辑器，找到 计算机配置-Windows设置-安全设置-账户策略-密码策略 中，把 密码必须符合复杂性 要求禁用。然后去 控制面板-用户账户 中输入当前密码， 新密码留空 ，确认后就把密码取消了。
虽然取消了密码，但是开机还需要按Ctrl+Alt+Del ，来开机，这个时候就需要进行账户配置。我们需要进入系统后，按Win+R键打开[运行]，输入secpol.msc回车打开 [本地安全策略-本地策略-安全选项] 找到 [交互式登录:无须按Crtl+Alt+Del] 并双击打开设为启用。
顺便到下面找到并禁用 [账户:使用空密码的本地账户只允许进行控制台登录] ，以便在远程登陆时能够成功免密码登录，
为了让开机直接能够进入系统，不需要任何操作，我们还需要进行一步。通过 **Win+R[运行]control userpasswords2** ，从而打开 [本地用户账户设置] ，取消勾选**[要使用本机，用户必须输入用户名和密码]**并确认。
重启之后对账户进行修改，打开 [服务器管理器-本地服务器] 点击计算机名，可以直接在弹窗中更改你的 计算机描述 ，点击下面的更改进入二级选单，更改计算机名为“你的名字”，这里防止冲突不推荐把计算机名和管理员名设置成相同的，最好能使用两个独立的名字。</description>
    </item>
    
    <item>
      <title>一个测试终端 IO 速度的脚本</title>
      <link>https://blog.sh1mar.in/post/linux/write-a-script-to-test-terminal-io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sh1mar.in/post/linux/write-a-script-to-test-terminal-io/</guid>
      <description>前言 今天学到了一个新的知识：终端的绘制性能会影响程序的性能。当一个程序以单线程 运行时，终端输出和文件 IO 都在同一个线程，终端如果绘制速度慢，因为 IO 是阻塞的 ，程序内部的 stdout 执行速度也会下降。
测试 那么有什么办法可以测试一下哪些终端绘制速度比较快呢？我在 Rust CN 群看到的这 么个办法：同时跑文件 IO 和终端 IO 来测试。有一个方式是用 find 来遍历系统内 所有文件，因为 find 毎找到一个文件都会输出一次，我们从根目录开始 find，就可 以实现同时高频率的文件 IO 和终端 IO 了。所以这里我们只需要简单的 find / 即 可。
而运行时间的测试则用 shell 提供的 time 函数来测试。
为了比对各个终端，我做了一些额外工作来获取终端的名字。具体脚本如下：
#!/bin/bash  # 这里获取运行中的终端名字 get_terminal() { PARENT_SHELL=$(ps -p $$ -o ppid=) PARENT_TERMINAL=$(ps -p $PARENT_SHELL -o ppid=) TERMINAL=$(ps -p $PARENT_TERMINAL o args=) printf $TERMINAL } # 测试 time find / # 方便分清各个不同的终端 echo -e &amp;#34;\n\nTesting in terminal: $(get_terminal)&amp;#34; 结果 其中 Alacritty 和 simple terminal 打得不相上下，而 kitty 稍逊一筹，konsole （右下） 是最慢的。后续我再运行了几次结果都相近。</description>
    </item>
    
    <item>
      <title>两步搞定定制Speedtest</title>
      <link>https://blog.sh1mar.in/post/%E4%B8%A4%E6%AD%A5%E6%90%9E%E5%AE%9A%E5%AE%9A%E5%88%B6speedtest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sh1mar.in/post/%E4%B8%A4%E6%AD%A5%E6%90%9E%E5%AE%9A%E5%AE%9A%E5%88%B6speedtest/</guid>
      <description>前言 欢迎使用我的定制speedtest，点击打开或者点击网页右上角的WiFi按钮打开。
使用定制Speedtest你需要准备：
 一个好看的网站PNG|JPG文件 一个电话号码 一个可用域名 初中英语水平  注册SpeedTest账号 打开https://speedtest.net,点击右上角的Enterprise-Speedtest CUstom。然后会跳转页面，点击start for free。
选择Free Plan Selected，点击下面的Next按钮。
填写完之后点击Next然后这里就看自己的需求填写了，我是都没有所以都没有勾选。点击Next下一步
然后只勾红框一个选项就可以了，第二个是广告，没必要勾。然后点击Create Account,跳转邮箱验证。
定制页面 进入账户，点击custom：
首先第一个选项框，自定义好二级域名，勾选上HTTPS：
然后点击第二个Interface：
 Colors: 背景色和强调色
Company Logo选个高大上一点的，或者自己DIY一个图标
 假如你没有自己的服务器给人家测速，就选第一个。
然后假如要放在自己网页里的话，在Test URLs填入你的域名白名单。</description>
    </item>
    
    <item>
      <title>使用 FRP 实现一机多设备编程</title>
      <link>https://blog.sh1mar.in/post/%E4%BD%BF%E7%94%A8-frp-%E5%AE%9E%E7%8E%B0%E4%B8%80%E6%9C%BA%E5%A4%9A%E8%AE%BE%E5%A4%87%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sh1mar.in/post/%E4%BD%BF%E7%94%A8-frp-%E5%AE%9E%E7%8E%B0%E4%B8%80%E6%9C%BA%E5%A4%9A%E8%AE%BE%E5%A4%87%E7%BC%96%E7%A8%8B/</guid>
      <description>前言 最近配了台 ChromeBook 用来方便平常通勤写代码，但是 ChromeBook 羸弱的性能和拉跨的散热使得他日常编程体验极其垃圾。同时，回到宿舍之后用主机写代码和 ChromeBook 之间也会极其脱节。
也有考虑过用 git 分支来管理代码，但是有时候代码写了一半还有很多问题没调试，不想提交 commit 。或者使用 SAMBA 直接对笔记本的代码进行修改，这样又会遇到跨平台编译的问题。
于是我用了一段时间的 VSCode 的 Remote SSH 插件，在外用 ChromeBook，回到宿舍之后主机 SSH 连接 ChromeBook 来写代码。但是这样有些本末倒置了：本来性能更好的主机却只做了显示器的功能。于是我这周和朋友了解了一下 frp 并重新设计了部署方案。
设计 一机多设备编程部署方案：
一台高性能的本地服务器主机用作编译主机，部署 frp 服务到一台有公网 IP 的 VPS主机上，然后别的设备通过 VPS 转发流量到本地主机上来操作本地服务器。
平台 我的本地服务器用的 Ubuntu 20.4，公网服务器用的 Debian Buster。
部署 首先下载 FRP ，根据自己的系统和处理器选择，我这边选的 linux-amd64 版本。解压之后里面有两个程序，一个是 frps ，一个是 frpc ，分别对应服务器和客户端两个程序。
 下面所述的字段在 FRP Docs 里都有详细介绍，你可以根据自己需求更改。
 FRPS（服务器端） 将 frps 和 frps.ini 用 SFTP 发送到公网IP服务器，然后修改 frps.ini ：</description>
    </item>
    
    <item>
      <title>使用 Python 实现 JSON Web Token</title>
      <link>https://blog.sh1mar.in/post/%E7%94%A8python%E5%AE%9E%E7%8E%B0jwt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sh1mar.in/post/%E7%94%A8python%E5%AE%9E%E7%8E%B0jwt/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;涉及到无状态鉴权时，&lt;code&gt;Token&lt;/code&gt; 是比较好的验证用户身份的方案，而 &lt;code&gt;Token&lt;/code&gt; 如何制作也是一个设计难点。只是一个 &lt;code&gt;Token&lt;/code&gt; 去下载模块又增加依赖的负担，于是我去学习了 &lt;code&gt;JWT(JSON Web Token)&lt;/code&gt; 的设计方式。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用CloudFlare CDN</title>
      <link>https://blog.sh1mar.in/post/%E4%BD%BF%E7%94%A8cloudflare%E5%88%86%E9%85%8Dcdn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sh1mar.in/post/%E4%BD%BF%E7%94%A8cloudflare%E5%88%86%E9%85%8Dcdn/</guid>
      <description>&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;CloudFlare是真的减速器，假如服务器在香港可能上了CF会很慢，所以假如像我一样用完延迟从60ms蹦到500ms的，就不要搞CF了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用Linux搭建NAS</title>
      <link>https://blog.sh1mar.in/post/linux%E4%B8%8B%E9%85%8D%E7%BD%AEnas%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93%E7%BB%8F%E9%AA%8C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sh1mar.in/post/linux%E4%B8%8B%E9%85%8D%E7%BD%AEnas%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93%E7%BB%8F%E9%AA%8C/</guid>
      <description>Linux下配置NAS的一些总结经验 前言 经历了上一次的Windows Server的痛苦配置以后，我决定换成Linux来配置NAS。相对于Windows平台，Linux平台会更加自由和简洁。而且清晰的权限和后台也要比Win更加干净，唯一的弊端就是要去学不少命令。但是我这里会帮你总结好大部分要用到的命令，快速帮你搭建好Linux平台下的NAS。
Linux的系统选择 我选择的是Ubuntu 18.04。但是对于NAS来说，稳定且更新少是必要需求，所以我更加推荐Arch Linux。简洁干净，最好减少桌面配置，减少GPU占用。
配置思路  SMB高速传输 基于Web的离线下载 SSH命令行和Web页面管理系统   系统安装 下载好.iso文件以后，用UltraISO烧录进U盘里。然后重启，按F12进入BIOS，检查启动列表，要打开UEFI启动选项。然后保存设置退出，按F8打开启动列表，选择UEFI 你的U盘。进入系统选择第一项，直接安装。关于硬盘配置，我只有一个SSD和一个HDD，所以把系统安装在SSD，让安装程序自动分区，HDD自动挂载用来做数据盘。其余没什么好说的，按照自己的需求一直下一部就行了。
NAS正式配置 SAMBA配置 一、安装Ubuntu SAMBA服务器
 更新软件源：输入命令sudo apt-get update更新软件源 安装SAMBA服务：输入命令sudo apt-get install samba安装SAMBA服务器。  二、创建SAMBA配置文件
 创建共享目录：sudo mkdir -p /你的共享文件夹路径 #mkdir -p 用来创建路径中不存在的路径。 修改配置文件：sudo vim /etc/samba/smb.conf #没有vim的请输入命令sudo apt-get vim  vim的使用方法  进入配置文件之后，按i进入编辑模式，把所有字段全部删除，输入以下配置(#号后注释文字要删除）：
[你的配置名] #这里是分享路径配置 comment = User&amp;#39;s NAS #这一段是标记，对配置没有影响。 path = /你的共享文件夹路径 #写上你自己的共享路径 read only = no #是否只读 browseable = yes #是否可浏览 [另一个配置名] #如果同一台机子你想分开共享路径，就把上面的配置复制到这里。 三、创建SAMBA用户</description>
    </item>
    
    <item>
      <title>去你的 emo 和内卷</title>
      <link>https://blog.sh1mar.in/post/fuck-emo-and-involution/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sh1mar.in/post/fuck-emo-and-involution/</guid>
      <description>今天在水群的时候，和群友们聊起了 “emo 和卷一样被 abused” 的话题。虽然两个词已经不是现在的潮流了（对的，只过了一个 月网友们就已经更新换代了），但是借着这个话题我还是发表了 一些感慨。
聊之前还是得先说一下背景故事。卷就是内卷化的缩写，在格尔 茨，黄宗智等学者看来，内卷是指缺乏经济竞争导致农耕社会未 能进入工业化转化成资本主义经济。而现代网民赋予给这个词的含 义是修饰一种不断压榨自己去获得微小竞争力的状况。也形容过 度竞争。比如有一家公司规定工作时间 8h，有员工为了获取管 理层赏识，自愿故意加班。而原来按时上下班的人会因此担心被 淘汰也开始自愿加班，最后加班变成了常态，最后演变成低水平 的内部竞争。
而 emo 原来是 emotional hardcore 的缩写，是用来描述一种 和摇滚相似但是更注重情感主题的音乐类型。Emotional hardcore 的乐迷通常有躁动，敏感，忧郁等性格特征，因此在 现代被拿来与 “丧”，“忧郁” 等情感所绑定，引申出了“我 emo 了” 等网络用语。
内卷化这个词在公众热议 996 现象的时候非常流行，但是在一 段时间的讨论之后，大家好像疲于 996，连三个字都不愿意打， 最后只用 “卷” 一个字来表达内卷化的意思。内卷化的含义， 也在一次又一次的网络用语更新中，变成指责个人的努力。很 多人现在一看到别人在学习，就说 “你这个人怎么这么卷”， “别卷了，别卷了”。Emo 也在网民的多次网络用语更新之后附 上了抑郁忧郁的含义，没有人还记得 emo 原意是指代一个摇滚 流派。
即使我不原教旨主义，我承认 emo 有忧郁的意思，我承认卷 可以用来嘲讽工贼，但如果一个人有事没事就发条微博说 “我 emo 了”，实际 ta 可能只是胖了几斤，或者没抢到优惠券 、一个人看到别人在读书或者写题就说别人在卷，实际上他自己 今天刚打了十几场排位赛，我觉得这样的用法是滥用。但气人 的是，上述现象并不小众，而是一种流行现象。
看着这种怪异的现象我实在有点烦。我看到 emo 这个新词，查 到意思之后的第一反应是：“就这？”，而看到有人发自己 emo 了，了解了详情之后心理还是同样的 “就这？” 的反应。 我觉得 emo 这个词的流行只是缘由于一群做作的 bitch 想找 一个词企图为自己的做作做掩饰，没有人会在 emo 出现 前因为微不足道的不止一提的小事大肆发表自己的情绪，因为 他们知道可能会给人说自己做作。而动不动就说别人卷的人 ，也不过是一群懒狗，看到别人比自己努力就想要拖人家下水， 给自己找一个摸鱼的借口罢了。</description>
    </item>
    
    <item>
      <title>在Linux系统下玩Minecraft</title>
      <link>https://blog.sh1mar.in/post/%E5%9C%A8linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%8E%A9minecraft/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sh1mar.in/post/%E5%9C%A8linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%8E%A9minecraft/</guid>
      <description>Java环境安装   打开终端
  通过包管理器安装OpenJDK8（直接放弃甲骨文的官方JDK，配置无敌麻烦。）
# Ubuntu/Deepin sudo apt-get install openjdk8 # Arch/Manjaro sudo pacman -S jdk8-openjdk sudo pacman -S jre8-openjdk   3.有时候会有报错，记得检查是否安装openjfx8
HMCL下载 基本上大部分的Minecraft资源站都有各种版本HMCL资源，谷歌一下。这里有一份稍微新版本的HMCL备份。—&amp;gt;HMCL-3.2.130版本备份资源&amp;lt;—
正式开玩   HMCL启动
# 进入HMCL所在目录 cd ~/Downloads # 启动HMCL java -jar HMCL-xxx.jar   MC启动
    首先先把各种个人信息项设置好。
  进入游戏列表，打开安装新游戏版本，自己选择一个版本安装。
游戏安装页面
  注意先下载游戏，再安装整合包。 
  游戏安装成功之后，点击下载好的游戏右侧的齿轮图标，点击自动安装，上方菜单栏选择在线安装。先安装Forge，再安装OptiFine
  然后点击游戏设置，调整一下游戏内存和窗口分辨率
  最后点击顶上的主页按钮，左下角开始游戏。
Mod和光影安装   打开MC文件夹下载目录</description>
    </item>
    
    <item>
      <title>如何配置 Arch Linux</title>
      <link>https://blog.sh1mar.in/post/configure-arch-linux/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sh1mar.in/post/configure-arch-linux/</guid>
      <description>Network Update 安装必要的软件 添加用户 在 VMWare 上装 Arch 的设置（可选）  添加驱动 安装   安装桌面环境  Install Display manager 自启动 HiDPI   分辨率 装点别的  输入法 Network manager 字体 终端 壁纸 通知系统   主题 常见错误  Network 如果你有跟着我上一篇文章，安装了 NetworkManager，此时你 可以输入命令 nmtui 来打开一个终端网络管理器来管理网络。
#启动网络管理器的 daemon systemctl start NetworkManager.service #设置为开机自启动 systemctl enable NetworkManager.service #启动终端管理器 nmtui 如果没有安装，那你可能需要把 U盘插上，mount 好分区之后 重新 chroot，并安装需要的网络管理器。
Update 然后执行命令更新：
pacman -Syu 安装必要的软件 pacman -S man base-devel 添加用户 创建一个叫做 TOM 的用户（把 TOM 换成你的名字）：</description>
    </item>
    
    <item>
      <title>快速配置Typecho</title>
      <link>https://blog.sh1mar.in/post/typecho%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sh1mar.in/post/typecho%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2/</guid>
      <description>&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;因为Hexo迁库太麻烦了，而我经常忘记备份。而且每次写文章都要先渲染成静态页面。所以整了个Typecho，随时随地写文章，迁站只要宝塔一键就完事。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>用阿里云OSS做图床</title>
      <link>https://blog.sh1mar.in/post/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%81%9A%E5%9B%BE%E5%BA%8A/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sh1mar.in/post/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%81%9A%E5%9B%BE%E5%BA%8A/</guid>
      <description>购买资源包 直接买LRS标准就可以了，按照自己需求买，不过存几张图而已40G够用了。
然后买下行流量包，这里的流量是每月刷新的。
 嫌贵的话其实可以不买，直接按实际流量扣费，0.25/GB。但是要做好被DDos或者突然高访问量然后一夜负债房子卖掉。
 Bucket创建   Bucket名称要填独一无二的，同时也不要太长，方便自己 选择哪里都无所谓，但是一定要选国内的 存储空间选标准   下载PicGo PicGo是一个方便的批量上传图片的软件，而且也能管理自己的图片链接，在作者的GitHub Release里下载安装。
配置图床 AccessKey获取 首先要取得OSS的访问秘钥，鼠标移至阿里云控制台右上角的头像处，点击Access Key管理，点击创建Access Key。然后点击开始使用子用户Access Key。
接着就会跳转创建用户，输入一个账户名，勾选编程访问，点击确定创建。
创建完成会跳转到用户信息，请一定要现在就保存好这个ID 和Secret，这里的信息只会显示现在这一次。可以下载CSV或者点复制保存。
然后点添加权限，选择管理对象存储服务权限一个就够了。
配置PicGo 然后打开PicGo，选择阿里云图床，输入刚刚的AccessKey和其他信息：
  存储空间名是刚刚的bucket名。 存储区域是一开始选择的区域，可以在bucket信息里面找endpoint信息。 存储路径请一定保证OSS有这个目录。   然后就在上传区直接拖动照片上传就可以了。</description>
    </item>
    
    <item>
      <title>白嫖博客指南</title>
      <link>https://blog.sh1mar.in/post/hexo/build-hexo-with-cf-pages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sh1mar.in/post/hexo/build-hexo-with-cf-pages/</guid>
      <description>白嫖博客指南 因为我的机子又小又弱，顶不住 DDoS，我一直是处于怂逼 状态，不敢把博客公开，都是自己用。然后最近发现，其实 我也没什么国内访问的需要，为啥不转移到托管平台呢？ 于是这周稍微折腾了一下，把博客从 vps 的 nginx 转移 到了 CloudFlare Pages 上。
具体思路 本地建立 hexo 环境，建立 git 仓库，把源文件 stage 到 master 分支，提交到 GitHub 时使用 Actions 编译， 然后把静态文件 stage 到别的分支。CloudFlare 监听 这个静态文件的分支，有静态文件变动就生成。最后域名 CNAME 到 CloudFlare 就可以了。
预备需求  一个 GitHub 帐号 一个 CloudFlare 帐号 一个终端 曾经使用过 hexo (没有的话看 hexo 的文档) （可选）一个自己的域名  Hexo 安装  我因为常用 Arch Linux 所以就只基于 Arch 环境来讲 一些终端操作。如果你发现环境不一样，你可以试着开个 docker 来运行。或者你也可以到我的 仓库 issues 来询问我。
 首先需要安装 nvm 。 跟着 README 的安装指引一步一步来就好。安装好之后 开始安装 node 和 npm</description>
    </item>
    
    <item>
      <title>让你的 neovim 像 IDE 一样强大</title>
      <link>https://blog.sh1mar.in/post/neovim/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sh1mar.in/post/neovim/</guid>
      <description>让你的 NeoVim 和 IDE 一样强大 前言 Neovim 是一款完全拥有 vim 特性且拥有高度支持插件的编辑器软件，而他的高可自定义能力也深深吸引了像我这样的人。这篇文章我会带着你编写一个漂亮且强大的终端编辑器的配置文件，同时稍微的带你入门一点 neovim，但没那么零基础哦。
我的配置文件在 Avimitin/nvim , 欢迎 fork 使用。
下载安装 neovim 有一个很重要的 pop_up_windows 弹出窗口特性在 0.5.0 版本才有，还有很多 TUI 的支持，蛮多插件依赖于这些特性的，所以我不建议在默认源的包管理器中下载稳定版的 0.4 版本。关于 neovim 的安装指南在 wiki 里面有，Ubuntu 的话也可以通过添加 PPA 源的方式，添加 unstable 源用 apt 包管理器安装：
# 如果你已经安装了，先卸载 sudo apt remove neovim # 添加 0.5.0 的源 sudo add-apt-repository ppa:neovim-ppa/unstable sudo apt-get update sudo apt install neovim 安装好 neovim 之后，还需要安装 Python3 和 NodeJS 来获得完全的插件支持：
sudo apt install python3 python3-pip NodeJS 非常不推荐在包管理器中安装，建议查看 NVM 安装教程或参考这篇文章 。</description>
    </item>
    
    <item>
      <title>黑苹果安装教程</title>
      <link>https://blog.sh1mar.in/post/%E9%BB%91%E8%8B%B9%E6%9E%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sh1mar.in/post/%E9%BB%91%E8%8B%B9%E6%9E%9C/</guid>
      <description>前言 本篇文章的目的是为了减少新手爬贴的麻烦，但是怕麻烦的人尽早放弃黑苹果。一旦决心折腾黑苹果了，就一定要耐心做下去。黑苹果的安装就是刚完成一个环节下一个环节就会有可能出问题的折腾历程。如果对自己的耐性没有信心还是尽早去淘宝叫人花50块钱给你装。
假如出现了文章内没有出现的问题怎么办呢，这里有很多黑苹果的论坛，多查多看帖子。
 远景(目前关闭注册，看看教程贴就好了，资源是没法下载的了) Tonymacx86.com(资源丰富，建议去注册一个账号） Github(善用GitHub的搜索功能，里面有很多很好用的教程仓库)  准备环节 硬件 首先要清楚的了解自己的设备型号，包括但不限于主板，CPU，显卡，声卡，网卡。将你的硬件型号写个备忘录记起来。假如是AMD显卡用户，恭喜你你不仅可以安装Mojave，因为AMD免驱，还可以减少很多配置步骤。而N卡用户，就直接放弃Mojave装High Sierra吧，Mojave只有开普勒架构的N卡才能免驱，而N卡的驱动只支持到High Sierra。
黑苹果安装的具体的硬件依赖看这：—&amp;gt; 🖥️
假如你还没有电脑，打算低价打造高性能苹果机，这里有硬件购买指南。文章会告诉你需要避免购买哪些不支持的硬件。
看不懂英文？这里有中文购买指南，已经帮你设计好购买套餐了。
最后你还需要一台Windows设备和一个8G以上的U盘。
软件  黑苹果需要很多工具，所以这里的篇幅会很长，读起来并且下载完需要费一些时间。但是还请做好准备工作，不要等出问题再去查再去下载，无意义地浪费很多时间。
 安装黑苹果你需要简单了解并使用：
 GUID分区表 ESP分区 Clover config.plist [High Sierra 镜像](#High Sierra 镜像) BIOS  GUID分区  MBR 分区表的组织限制了最大可寻址存储空间为 2 TB。因此它只支持最多 4 个主分区，或者 3 个主分区和 1 个扩展分区组合。然而，随着时代的进步，更大的存储设备需要应用到计算机领域。因此,取代 MBR 分区的 GUID 分区表 (GPT) 在新电脑中被使用，GPT 可以与 MBR 共存，以便为旧系统提供某种有限形式的向后兼容性。
 黑苹果必须使用GPT分区表，你需要将安装Windows的硬盘数据进行备份，然后使用分区工具对硬盘重新分区。微软官方有MBR转GPT的教程。
ESP分区  几乎所有 2012 年后生产的计算机都支持引导 UEFI，而且不再执行以前的 “Legacy” 标准。这些计算机需要一个 ESP 分区来引导。ESP 代表 EFI 系统分区，使用 FAT32/FAT16 文件系统。ESP 负责存储固件启动时使用的EFI 引导加载程序和其他实用程序。如果您不小心删除了这个分区，您的系统将无法再引导。为了安全起见，ESP 是默认隐藏的，因此它没有驱动器号。</description>
    </item>
    
  </channel>
</rss>
