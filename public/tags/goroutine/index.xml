<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>goroutine on sh1marin&#39;s Blog</title>
    <link>https://blog.sh1mar.in/tags/goroutine/</link>
    <description>Recent content in goroutine on sh1marin&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://blog.sh1mar.in/tags/goroutine/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Golang Polling Control Flow</title>
      <link>https://blog.sh1mar.in/post/golang/circulate_job_gurdian_in_go/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sh1mar.in/post/golang/circulate_job_gurdian_in_go/</guid>
      <description>Go 的循环任务守护 前言 这几天在做的一个项目里，有一个功能需求是：长期运行一个轮询任务，通过轮询得到的返回的信息进行下一步操作。这个问题初一看是蛮简单的，就一个 for 循环的事情嘛。但是实际上还有很多细节的地方需要仔细处理。本篇文章建立在你有足够的 Go 语言基础且懂得 chan 、 select 、go 关键字的用法的基础上。文章代码是逐步完善的伪代码，请自行推演，不要复制粘贴。
简单的无限循环 基于分治的思想，我们把这个任务给分成几个小任务：
 执行一次请求 把一次请求改为轮询 对执行中的轮询进行控制  首先先写好请求的代码：
package main import ( &amp;#34;net/http&amp;#34; &amp;#34;log&amp;#34; &amp;#34;fmt&amp;#34; ) func Request(url string) ([]byte, error) { resp, err := http.Get(url) if err != nil { log.Println(&amp;#34;[Error]Http get error,&amp;#34;, err) return nil, err } return resp, nil } func main() { resp, err := Request() if err != nil { log.Println(&amp;#34;[Error]Request error,&amp;#34;, err) return } fmt.</description>
    </item>
    
  </channel>
</rss>
