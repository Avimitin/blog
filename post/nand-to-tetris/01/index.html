<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=zh><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Nand To Tetris 第一章记录 - sh1marin's blog</title><meta name=theme-color><meta name=description content="知识点摘要 芯片本身由大量布尔门组合构建而成 任何布尔算子 (Boolean Operator) 都可以只用 Nand: NOT( x AND y ) 或者 Nor: NOT( x OR y ) 构建而成。 可以把门看作是一个黑箱函数：只关心"><meta name=author content="sh1marin"><link rel="preload stylesheet" as=style href=https://blog.sh1mar.in/main.min.css><script defer src=https://blog.sh1mar.in/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=preload as=image href=https://blog.sh1mar.in/theme.png><link rel=preload as=image href=https://blog.sh1mar.in/github.svg><link rel=preload as=image href=https://blog.sh1mar.in/rss.svg><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<link rel=icon href=https://blog.sh1mar.in/favicon.ico><link rel=apple-touch-icon href=https://blog.sh1mar.in/apple-touch-icon.png><meta name=generator content="Hugo 0.112.3"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><meta property="og:title" content="Nand To Tetris 第一章记录"><meta property="og:description" content="知识点摘要 芯片本身由大量布尔门组合构建而成 任何布尔算子 (Boolean Operator) 都可以只用 Nand: NOT( x AND y ) 或者 Nor: NOT( x OR y ) 构建而成。 可以把门看作是一个黑箱函数：只关心"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.sh1mar.in/post/nand-to-tetris/01/"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-03-10T00:00:00+08:00"><meta property="article:modified_time" content="2024-03-10T00:00:00+08:00"><meta itemprop=name content="Nand To Tetris 第一章记录"><meta itemprop=description content="知识点摘要 芯片本身由大量布尔门组合构建而成 任何布尔算子 (Boolean Operator) 都可以只用 Nand: NOT( x AND y ) 或者 Nor: NOT( x OR y ) 构建而成。 可以把门看作是一个黑箱函数：只关心"><meta itemprop=datePublished content="2024-03-10T00:00:00+08:00"><meta itemprop=dateModified content="2024-03-10T00:00:00+08:00"><meta itemprop=wordCount content="958"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Nand To Tetris 第一章记录"><meta name=twitter:description content="知识点摘要 芯片本身由大量布尔门组合构建而成 任何布尔算子 (Boolean Operator) 都可以只用 Nand: NOT( x AND y ) 或者 Nor: NOT( x OR y ) 构建而成。 可以把门看作是一个黑箱函数：只关心"></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold" href=https://blog.sh1mar.in>sh1marin's blog</a><div class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-6"><a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/about/>About</a></nav><nav class="mt-12 flex justify-center space-x-10 dark:invert lg:ml-12 lg:mt-0 lg:items-center lg:space-x-6"><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/Avimitin target=_blank rel=me>github</a>
<a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./rss.svg) href=https://blog.sh1mar.in/index.xml target=_blank rel=alternate>rss</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-3xl px-8 pb-16 pt-12 dark:prose-invert"><article><header class=mb-16><h1 class="!my-0 pb-2.5">Nand To Tetris 第一章记录</h1><div class="text-sm antialiased opacity-60"><time>Mar 10, 2024</time>
<span class=mx-1>&#183;</span>
<span>sh1marin</span></div></header><section><h1 id=知识点摘要>知识点摘要</h1><ul><li>芯片本身由大量布尔门组合构建而成</li><li>任何布尔算子 (Boolean Operator) 都可以只用 <em>Nand</em>: <code>NOT( x AND y )</code> 或者 <em>Nor</em>: <code>NOT( x OR y )</code> 构建而成。</li><li>可以把门看作是一个黑箱函数：只关心输入和输出，而不需要关注内部的实现。</li><li>每个复杂的门电路都是很多基础的门组合形成的。</li><li>只要拥有 <em>转换</em> 和 <em>传导</em> 两个特性的硬件都可以用作门的物理实现。</li><li>组合门的能力本身是一门逻辑学，之后最好去补一下电路设计和逻辑设计两门教材。</li></ul><h1 id=作业纠错>作业纠错</h1><p>给定一个黑箱 Nand：</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>CHIP Nand {
</span></span><span style=display:flex><span>  IN a, b;
</span></span><span style=display:flex><span>  OUT out;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>已知 <code>Nand: if a = b = 1 then out = 0 else out = 1</code> 的情况下，实现 Not 很简单，将输入 a 接到 Nand 的输入 a，常量 1 接到 Nand 的输入 b 就行。</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>NOT = Nand(a = in, b = true, out = out)
</span></span></code></pre></div><p>而 Nand 本身的语义，就是在 And 的结果上套了 Not，所以想得到 And 就是在 Nand 上再套一次 Not。</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>AND = Not(Nand(a = a, b = b))
</span></span></code></pre></div><p>接下来的 Or 门实现的难度主要在逻辑学上了。
首先需要知道 <a href=https://en.wikipedia.org/wiki/De_Morgan%27s_laws#Substitution_form><em>De Morgan&rsquo;s laws</em></a>，
理解 <code>OR = NOT( NOT(a) AND NOT(b) )</code> 之后，再实现电路就比较简单了。</p><p>有了 OR 之后再实现 XOR 也是一样组合逻辑： <code>XOR = (A AND NOT B) OR (NOT A AND B)</code></p><p>Mux 的实现与 XOR 有点相似，只不过多了一个变量 SEL: <code>MUX = (a AND NOT sel) OR (b AND sel)</code></p><p>DMux 稍微有些不同，虽然是组合逻辑，但其有了两个可能的输出，在写 HDL 的时候也会需要写两个 OUT：</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>IN in, sel
</span></span><span style=display:flex><span>OUT a, b
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>a = in AND NOT sel
</span></span><span style=display:flex><span>b = in AND sel
</span></span></code></pre></div><p>Multi-bit gate 很简单，就是对着输入的每一位复制粘贴单 bit 的 gate 操作：</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>Mux(a = a[0], b = b[0], sel = sel, out = out[0]);
</span></span><span style=display:flex><span>Mux(a = a[1], b = b[1], sel = sel, out = out[1]);
</span></span><span style=display:flex><span>Mux(a = a[2], b = b[2], sel = sel, out = out[2]);
</span></span><span style=display:flex><span>Mux(a = a[3], b = b[3], sel = sel, out = out[3]);
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>但 Multi-way gate 就需要发挥一些想象力了。比方对于一个 4 way 的 Mux 操作，sel 会是 2 bit 的输入，对于不同的 sel 组成，这里列出所有可能的输出:</p><table><thead><tr><th>sel</th><th>out</th></tr></thead><tbody><tr><td>00</td><td>a</td></tr><tr><td>01</td><td>b</td></tr><tr><td>10</td><td>c</td></tr><tr><td>11</td><td>d</td></tr></tbody></table><p>对于 Multi-way 的 gate 实现，需要用一种淘汰赛的思维方式来 reduce 输出可能性。
在上面的表格中，可以把 <code>sel[0]</code> 分为一组可能输入，把 <code>sel[1]</code> 分为一组可能输入。
将这两组分别 Mux 到一个内部 pin 上：</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>Mux(a = a, b = b, sel=sel[0], out = tmp0);
</span></span><span style=display:flex><span>Mux(a = c, b = d, sel=sel[0], out = tmp1);
</span></span></code></pre></div><p>在 sel[1] 为 0 的时候，tmp0 管线就有 a 或者 b 的输出，而在 sel[1] 为 1 的时候，tmp1 就有着 c 或者 d 的输出。
最后再将这两个 tmp 管线 Mux 一下，就能得到最终输出：</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>Mux(a = tmp0, b = tmp1, sel=sel[1], out = out);
</span></span></code></pre></div><p>对于一个 N way 的 Mux，我们都可以嵌套套用 N/2 way 的 Mux gate 来组合实现。</p><p>DMux 也是类似的思路，只不过相对于 Mux 而言需要采取镜像反转的思考方式：
先将一条输入 DMux 到 Log2n 的管线上，然后将管线分组对应的pin脚，对着不同的管线连线 DMux 门：</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>// 4-way DMux
</span></span><span style=display:flex><span>DMux(in = in, sel = sel[0], a = ac, b = bd);
</span></span><span style=display:flex><span>DMux(in = ac, sel = sel[1], a = a, b = c);
</span></span><span style=display:flex><span>DMux(in = bd, sel = sel[1], a = b, b = d);
</span></span></code></pre></div></section><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]"><a class="flex w-1/2 items-center rounded-l-md p-6 pr-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=https://blog.sh1mar.in/post/ideology/why-i-hate-community/><span class=mr-1.5>←</span><span>【中二呓语】我开始讨厌群聊了</span></a>
<a class="ml-auto flex w-1/2 items-center justify-end rounded-r-md p-6 pl-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=https://blog.sh1mar.in/post/cmcc-rax3000m/><span>在中国移动 RAX3000M 上使用主线 openwrt 记录</span><span class=ml-1.5>→</span></a></nav></article></main><footer class="opaco mx-auto flex h-[4.5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2024
<a class=link href=https://blog.sh1mar.in>sh1marin's blog</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>Powered by Hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>✎ Paper</a></footer></body></html>