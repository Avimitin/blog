<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=zh><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Rust 的 futures 实现（WIP） - sh1marin's blog</title><meta name=theme-color><meta name=description content="翻译自 https://cfsamson.github.io/books-futures-explained/1_futures_in_rust.html 2. Rust 的 Futures 实现 在这一章中，你将会学到： Rust 的高层级并发概念 当你写 async 代码时，Rust 为你提供的东西和缺少的东西 为什么我们在写 async 时需要一个 runtime"><meta name=author content="sh1marin"><link rel="preload stylesheet" as=style href=https://blog.sh1mar.in/main.min.css><script defer src=https://blog.sh1mar.in/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=preload as=image href=https://blog.sh1mar.in/theme.png><link rel=preload as=image href=https://blog.sh1mar.in/github.svg><link rel=preload as=image href=https://blog.sh1mar.in/rss.svg><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<link rel=icon href=https://blog.sh1mar.in/favicon.ico><link rel=apple-touch-icon href=https://blog.sh1mar.in/apple-touch-icon.png><meta name=generator content="Hugo 0.112.3"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><meta property="og:title" content="Rust 的 futures 实现（WIP）"><meta property="og:description" content="翻译自 https://cfsamson.github.io/books-futures-explained/1_futures_in_rust.html 2. Rust 的 Futures 实现 在这一章中，你将会学到： Rust 的高层级并发概念 当你写 async 代码时，Rust 为你提供的东西和缺少的东西 为什么我们在写 async 时需要一个 runtime"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.sh1mar.in/post/coding/futures-explained/2-futures-in-rust/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-05-03T00:00:00+08:00"><meta property="article:modified_time" content="2022-05-03T00:00:00+08:00"><meta itemprop=name content="Rust 的 futures 实现（WIP）"><meta itemprop=description content="翻译自 https://cfsamson.github.io/books-futures-explained/1_futures_in_rust.html 2. Rust 的 Futures 实现 在这一章中，你将会学到： Rust 的高层级并发概念 当你写 async 代码时，Rust 为你提供的东西和缺少的东西 为什么我们在写 async 时需要一个 runtime"><meta itemprop=datePublished content="2022-05-03T00:00:00+08:00"><meta itemprop=dateModified content="2022-05-03T00:00:00+08:00"><meta itemprop=wordCount content="1862"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Rust 的 futures 实现（WIP）"><meta name=twitter:description content="翻译自 https://cfsamson.github.io/books-futures-explained/1_futures_in_rust.html 2. Rust 的 Futures 实现 在这一章中，你将会学到： Rust 的高层级并发概念 当你写 async 代码时，Rust 为你提供的东西和缺少的东西 为什么我们在写 async 时需要一个 runtime"></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold" href=https://blog.sh1mar.in>sh1marin's blog</a><div class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-6"><a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/about/>About</a></nav><nav class="mt-12 flex justify-center space-x-10 dark:invert lg:ml-12 lg:mt-0 lg:items-center lg:space-x-6"><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/Avimitin target=_blank rel=me>github</a>
<a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./rss.svg) href=https://blog.sh1mar.in/index.xml target=_blank rel=alternate>rss</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-3xl px-8 pb-16 pt-12 dark:prose-invert"><article><header class=mb-16><h1 class="!my-0 pb-2.5">Rust 的 futures 实现（WIP）</h1><div class="text-sm antialiased opacity-60"><time>May 3, 2022</time>
<span class=mx-1>&#183;</span>
<span>sh1marin</span></div></header><section><blockquote><p>翻译自 <a href=https://cfsamson.github.io/books-futures-explained/1_futures_in_rust.html>https://cfsamson.github.io/books-futures-explained/1_futures_in_rust.html</a></p></blockquote><h1 id=2-rust-的-futures-实现>2. Rust 的 Futures 实现</h1><blockquote><p>在这一章中，你将会学到：</p><ul><li>Rust 的高层级并发概念</li><li>当你写 async 代码时，Rust 为你提供的东西和缺少的东西</li><li>为什么我们在写 async 时需要一个 runtime 库</li><li>leaf-future 和 non-leaf-future 之间的区别</li><li>如何处理 CPU 密集任务</li></ul></blockquote><h2 id=future>Future</h2><p>所以 future 是什么？</p><p>future 用来代表一系列在现在不能立即完成，要过一段时间才能完成的操作。</p><p>Async Future 的完成在 Rust 里主要使用轮询(<code>Poll</code>)来实现，其中，一个异步任务将需要三个阶段来完成。</p><ol><li><strong>轮询阶段(The Poll phase)</strong>。当一个 <code>Future</code> 被轮询时，与其对应的任务继续将执行，
直至这个任务被执行到了某个阻塞操作，无法立刻完成而结束。
我们通常把 <strong>运行时(Runtime)</strong> 中对 <code>Future</code> 进行轮询的功能称作为 <strong>Executor</strong>。</li><li><strong>等待阶段（The Wait phase)</strong>。一个通常被称作 <code>reactor</code> 的事件资源，能够把 Future
的状态改变为等待状态，标注其正在等待某个事件的发生。这个 reactor 事件源可以确保当
Future 需要的事件发生时唤醒 Future 并继续执行任务。</li><li><strong>唤醒阶段(The Wake phase)</strong>。事件发生，<code>reactor</code> 唤醒 <code>Future</code>。然后轮到 <code>Executor</code>
继续轮询 Future，让这个 Future 从刚才的断点继续执行下去，直到遇到下一个阻塞操作或者
该 Future 已经完全完成才结束这一整个循环。</li></ol><p>接下来我们将要讨论一下 leaf-future 和 non-leaf-future。把这两个概念区分清楚是很重要的事情，
因为在生产实践中，这两种 future 差别是很大的。</p><h2 id=leaf-futures>Leaf futures</h2><p><em>leaf future</em> 由运行时 (Runtime) 创建，用来代表像套接字 (socket) 这样的资源。</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#fe8019>let</span> <span style=color:#fe8019>mut</span> stream <span style=color:#fe8019>=</span> tokio::net::TcpStream::connect(<span style=color:#b8bb26>&#34;127.0.0.1:3000&#34;</span>)
</span></span></code></pre></div><blockquote><p>译者注：诸如 <a href=https://tokio.rs>tokio</a>/<a href=https://async.rs/>async-std</a> 这样的
crates 提供了运行时库 (Runtime Library)。
而 async await 则是 rustc 内置的语法糖。这部分的概念容易搞混，请一定要区分开。</p></blockquote><p>对这些资源的操作，比如对 socket 进行读写操作，都是非阻塞操作。
这些操作会返回一个 future。这个返回的 future 就是 leaf 类型的 future。
称其为 leaf-future 的原因是，这种 future 是真的在被等待完成的 future。</p><p>除非你在自己写运行时(Runtime)，一般来说你都不需要自己实现 leaf-future。
不过这个教程将会把 leaf-future 的实现给过一遍。除此之外，你也不太可能
会需要将一个 leaf-future 交给运行时来执行。在下一章你就会知道原因。</p><h2 id=non-leaf-future>non-leaf-future</h2><p>non-leaf-future 则是运行时的使用者，也就是我们这些用户来创造的。
我们使用 <code>async</code> 关键字来创造一个异步的 <em>task</em>，然后交给运行时来执行。</p><p>一个异步的程序主要由 non-leaf-future 来组成，你可以把这种 future 看作一系列可以暂停的计算。
把概念弄清楚非常重要，因为这种 future 只代表一系列的操作。通常，这种 future
会用 <code>await</code> 来等待 leaf future 执行完成。</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#928374;font-style:italic>// Non-leaf-future
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#fe8019>let</span> non_leaf <span style=color:#fe8019>=</span> <span style=color:#fe8019>async</span> {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>let</span> <span style=color:#fe8019>mut</span> stream <span style=color:#fe8019>=</span> TcpStream::connect(<span style=color:#b8bb26>&#34;127.0.0.1:3000&#34;</span>).<span style=color:#fe8019>await</span>.unwrap();<span style=color:#928374;font-style:italic>// &lt;- yield
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    println!(<span style=color:#b8bb26>&#34;connected!&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#fe8019>let</span> result <span style=color:#fe8019>=</span> stream.write(<span style=color:#b8bb26>b</span><span style=color:#b8bb26>&#34;hello world</span><span style=color:#b8bb26>\n</span><span style=color:#b8bb26>&#34;</span>).<span style=color:#fe8019>await</span>; <span style=color:#928374;font-style:italic>// &lt;- yield
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    println!(<span style=color:#b8bb26>&#34;message sent!&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#fe8019>..</span>.
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>non_leaf.<span style=color:#fe8019>await</span>
</span></span></code></pre></div><blockquote><p>这里 <code>async { }</code> 把内部的各个操作包起来，然后把这一系列的操作包成 future
并传递给 <code>non_leaf</code> 这个变量。最后你可以等待新生成的 <code>non_leaf</code>。</p></blockquote><p>在上面的程序中，最关键的点在于那几个 <code>await</code> 关键字。每次调用 <code>await</code> 关键字
都会把当前的控制权交给运行时(Runtime)的任务管理器。当任务可以继续完成时，控制权
会重新交回给这个 future，而这个 future 不会从头开始执行，而是从刚刚 <code>await</code> 的地方继续执行。</p><p>相对于 leaf-future 而言，non-leaf-future 不被用来等待 I/O 资源。轮询 non-leaf-future
会让 future 运行到 leaf-future 的执行点，然后当 leaf-future 返回 pending 时，控制权
就被交还给 Runtime 管理了。</p><h2 id=runtimes>Runtimes</h2><p>像 C#, JavaScript, Java, Golang 以及其他众多语言通常都会自带运行时来处理并发。
在这些语言中，你只需要使用默认提供的 Runtime 库来管理并发就可以了。
和这些语言相比，Rust 并不自带处理并发用的运行时。你需要自己在众多的库中做出选择并导入到
自己的项目中。
所以如果你带着其他语言的并发模型来学 Rust 的 async await，会有很多纳闷的点。</p><p>因 Futures 而产生的大量复杂代码其实来源于运行时的复杂性。写一个高效的运行时是一件很难的事情。
而学习如何正确使用运行时也是一件需要费功夫的事情。不过你会发现在不同的运行时之间都有一些相似性。
学会使用一个 Runtime 能让你更轻松的阅读后面的篇章。</p><h3 id=async-runtime-的概念模型>async runtime 的概念模型</h3><p>我发现制造一个高层级的思维模型能更好的推断出 Futures 是怎么工作的。
要做到这一点，必须要介绍这个能执行完我们 Futures 的 runtime 的概念</p><p><strong>Rust 中一个完整的 async 系统将可以分成以下三部分</strong>：</p><ol><li>Reactor</li><li>Executor</li><li>Future</li></ol><p>这三个部分是如何协同工作的呢？他们通过一个叫做 <code>Waker</code> 的对象来实现。
Reactor 使用 <code>Waker</code> 来通知 Executor 某个 Future 已经准备好继续被执行了。即把
future 从睡眠状态中唤醒了。</p><p>一旦你理解了 <code>Waker</code> 的生命周期和所有权，你就能从用户的视角来明白 Future 的机制了。
下面是生命周期的过程：</p><ul><li>Executor 创建一个新的 <code>Waker</code>。一个常见，但不必要的做法是为每个在 Executor 注册
过的Future 都创建一个新的 Waker。</li><li>当 future 在 executor 注册时，它会在 executor 那获得一个 <code>Waker</code> 的拷贝。因为
<code>Waker</code> 用智能指针传输（就像 <code>Arc&lt;T></code> 那样），所有的拷贝都指向同个地址。因此任何
调用 <code>Waker</code> 拷贝的行为都能指向原初的 <code>Waker</code>，进而唤醒对应的 Future。</li><li>Future 拷贝 <code>Waker</code> 并把它传到 Reactor 来存储，等待稍后使用。</li></ul><p>在</p></section><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]"><a class="flex w-1/2 items-center rounded-l-md p-6 pr-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=https://blog.sh1mar.in/post/ideology/summary_for_mid_2022/><span class=mr-1.5>←</span><span>2022 年中忏悔</span></a>
<a class="ml-auto flex w-1/2 items-center justify-end rounded-r-md p-6 pl-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=https://blog.sh1mar.in/post/tools/osu_on_arch/><span>在 Arch Linux 上玩 osu stable</span><span class=ml-1.5>→</span></a></nav></article></main><footer class="opaco mx-auto flex h-[4.5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2024
<a class=link href=https://blog.sh1mar.in>sh1marin's blog</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>Powered by Hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>✎ Paper</a></footer></body></html>