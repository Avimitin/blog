 今天在廖雪峰博客里学了个返回函数，然后在闭包函数那里卡住了。

# 闭包变量引用

![](https://cdn.jsdelivr.net/gh/Avimitin/PicStorage/pic/20200421225437.png)

首先关于这一部分，教程里没有详细代码说明，这里post一个解释很详细的博客:[Python中闭包详解](https://www.cnblogs.com/s-1314-521/p/9763376.html)

我在这里简单讲一下我的理解：

```python
def aa()
	x = 0
    
    def bb()
    	x = 1
        return x
    return counter
```

在`aa`函数里的`x`变量，是属于`aa()`定义域里的变量，这里的`x`指向了`0`这个`int`对象。而在`bb()`函数里的`x`变量，是`bb()`定义域里的变量，这里的`x`则指向了`1`这个`int`对象。

所以在`bb()`里写`x = 1`只在`bb()`里引用，不会对`aa()`里的`x`起作用。

> 附带讲一下Python定义变量：
>
> Python中一切都是对象，0是对象，函数是对象，字符也是对象。`a = 1`这样的赋值语句不是开辟一个内存空间给`a`，而是开辟一个空间存放`1`。
>
> 赋值之后，`a`这个变量指向了内存中的`1`这个`int`对象。所以在Python 中的一切赋值操作，其实都类似于面向对象，将一个变量引向一个对象。
>
> 所以在Python中，会出现因为定义域搞混淆而重复指向对象的错误。关于这部分需要详细了解的可以看这个[官方介绍](https://docs.python.org/zh-cn/3/tutorial/classes.html#python-scopes-and-namespaces)

---

那么问题来了，廖雪峰讲的引用外部函数的局部变量是什么意思呢。其实是把`aa()`定义域里的变量对象指过来。可以拿到`aa()`定义域里`x`指向的对象，但是不能改变`aa()`定义域里`x`指向的对象。

简而言之，就是你可以拿到x的值，但是不能改变他的值。

所以假如要直接使用的话，只能使用`x`的值。

但是也不是不能在内部方法里改变外部方法的值，有两种办法：

- 使用一个可变参数，如字典，列表，使用`append`方法和`pop`方法增删值
- 在内部方法使用`nonlocal`关键字声明这个变量指向非本地对象，然后变量就会向上查询对象。

具体使用方法:

```python 
def cc()
	x = 0
    y = [1, 2]
    
    def dd()
    	nonlocal x
        x += 1
        y.append(3)
        return x, y
    return dd


cc()
ee = cc()
print(ee())
```

这个程序执行完之后会输出 `(1, [1,2,3])`

# 闭包到底是啥

一般的Python程序，在方法里进行赋值操作之后，内存会开辟一个空间存放变量指向的对象，方法执行完毕之后清除内存。而使用闭包的方法，内部函数假如引用了外部函数的局部变量，这个外部函数的变量会与内部函数捆绑，不会释放，直到整个程序结束。举个例子：

```python
def counter():
    x = 0
    # 这里检测counter()作用域中x的值
    print(x, end=',')
    # 改变一下x的值
    x += 1
    print(x, end=',')

    def count_counter():
        nonlocal x
        x += 1
        # 这里检测count_counter()作用域中x的值
        print(x, end=',')
        return x

    return count_counter

# 连续三遍执行程序，查看输出的值
a = counter()
# 先执行三遍counter()
counter(), counter(), counter()
# 再执行三遍count_counter()
a(), a(), a()
```

这个程序最后会输出：

```bash
0,1,0,1,0,1,0,1,2,3,4,
```

前半部分的3个`0,1`，就是单独调用`counter()`时的输出。可以看到每次执行完之后，内存都释放了，每次调用都重新从内存开辟空间，所以会先赋值`0`，然后再`+1`。而当调用内部函数时，外部函数的变量绑定到内部函数里，于是每次调用都不会重新开辟空间。

用面向对象的方法来思考会简单多一点，上面的解释是建立在没学过类的大白话解释。

---

所以闭包就是在函数内封装一个变量，然后供内部函数反复调用，因为外部函数返回内部函数名，看起来像封装起来了，所以叫闭包。

